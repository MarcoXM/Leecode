# 149. Max Points on a Line

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    def maxPoints(self, p: List[List[int]]) -> int:

        ## 

        def gcd(a, b):
            if b == 0:
                return a 
            else :
                return gcd(b , a % b)


        ans = 0
        for i in range(len(p)):
            maxv = 0
            slope_dit = {}
            for j in range(i+ 1, len(p)):
                dx = p[i][0] - p[j][0]
                dy = p[i][1] - p[j][1]
                g = gcd(dx, dy)
                slope_dit[(dx//g,dy//g)] = slope_dit.get((dx//g,dy//g),0) + 1
                maxv = max(maxv, slope_dit[(dx//g,dy//g)])
            ans = max(maxv + 1, ans )

        return ans

```
{% endtab %}

{% tab title="Go" %}
```go
func maxPoints(points [][]int) int {
    // 我只记得涉及到float的除法时要避免了。因为精度问题
    // 改用乘法/Mod..之前居然用写过....
    // 如何记录共线的呢 
    N := len(points)
    if N <= 1 {
        return N
    }
    var ans int
    
    for i:=0 ; i< N-1;i++ {
        slope := make(map[string]int)
        dup := 1
        max_ := 0
        for j:=i + 1; j < N;j++ {
            dx := points[i][0] - points[j][0]
            dy := points[i][1] - points[j][1]
            if dx == 0 && dy == 0 {
                dup++
                continue
            }
            
            g := gcd(dx,dy)
            if g != 0 {
                dy/=g
                dx/=g
            }
            // 转化为string, 因为没有Python的Tuple
            tmp_key := strconv.Itoa(dy)+"-"+strconv.Itoa(dx)
            if _,ok := slope[tmp_key];ok {
                slope[tmp_key] += 1
            }else {
                slope[tmp_key] = 1
            }
            max_ = max(max_,slope[tmp_key])
        }
        ans = max(max_ + dup,ans)
    }
    return ans
    
    
}
func max ( a,b int) int {
    if a>b {
        return a
    }
    return b
}

func gcd (a, b int) int {
    if b == 0 {
        return a
    } else {
        return gcd(b, a% b)
    }
}
```
{% endtab %}
{% endtabs %}

